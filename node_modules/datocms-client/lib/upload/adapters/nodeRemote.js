"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = nodeUrl;

var _tmp = _interopRequireDefault(require("tmp"));

var _axios = _interopRequireDefault(require("axios"));

var _fs = _interopRequireDefault(require("fs"));

var _path = _interopRequireDefault(require("path"));

var _url = _interopRequireDefault(require("url"));

var _decode = _interopRequireDefault(require("../../utils/decode"));

var _nodeLocal = _interopRequireDefault(require("./nodeLocal"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function nodeUrl(client, fileUrl, options) {
  var isCancelled = false;

  var _cancel = function cancel() {
    isCancelled = true;
  };

  var promise = new Promise(function (resolve, reject) {
    if (isCancelled) {
      return reject(new Error('upload aborted'));
    }

    return _tmp["default"].dir(function (err, dir, cleanupCallback) {
      if (err) {
        reject(err);
      }

      var encodedFileUrl = (0, _decode["default"])(fileUrl);

      var cancelTokenSource = _axios["default"].CancelToken.source();

      _cancel = function cancel() {
        isCancelled = true;
        cancelTokenSource.cancel();
        cleanupCallback();
        reject(new Error('upload aborted'));
      };

      if (isCancelled) {
        return _cancel();
      }

      return (0, _axios["default"])({
        url: encodedFileUrl,
        maxRedirects: 10,
        responseType: options.onProgress ? 'stream' : 'arraybuffer',
        cancelToken: cancelTokenSource.token
      }).then( /*#__PURE__*/function () {
        var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(response) {
          var data, onStreamEnd, streamPromise, totalLength, body, progressLength, redirectedUrl, _url$parse, pathname, filePath, _local, uploadPromise, cancelUpload;

          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  if (!options.onProgress) {
                    _context.next = 13;
                    break;
                  }

                  streamPromise = new Promise(function (_resolve) {
                    onStreamEnd = _resolve;
                  });
                  totalLength = response.headers['content-length'];
                  body = [];
                  progressLength = 0;
                  response.data.on('data', function (chunk) {
                    body.push(chunk);
                    progressLength += chunk.length;
                    options.onProgress({
                      type: 'download',
                      payload: {
                        percent: Math.round(progressLength * 100 / totalLength)
                      }
                    });
                  });
                  response.data.on('end', function () {
                    onStreamEnd(Buffer.concat(body));
                  });
                  response.data.on('error', reject);
                  _context.next = 10;
                  return streamPromise;

                case 10:
                  data = _context.sent;
                  _context.next = 14;
                  break;

                case 13:
                  data = Buffer.from(response.data);

                case 14:
                  /* eslint-disable no-underscore-dangle */
                  redirectedUrl = response.request._redirectable && response.request._redirectable._redirectCount > 0 ? response.request._redirectable._currentUrl : response.config.url;
                  /* eslint-enable no-underscore-dangle */

                  _url$parse = _url["default"].parse((0, _decode["default"])(redirectedUrl)), pathname = _url$parse.pathname;
                  filePath = _path["default"].join(dir, _path["default"].basename(pathname));

                  _fs["default"].writeFileSync(filePath, data);

                  _local = (0, _nodeLocal["default"])(client, filePath, options), uploadPromise = _local.promise, cancelUpload = _local.cancel;

                  _cancel = function cancel() {
                    cancelUpload();
                  };

                  return _context.abrupt("return", uploadPromise.then(function (result) {
                    _fs["default"].unlinkSync(filePath);

                    cleanupCallback();
                    resolve(result);
                  }, function (error) {
                    _fs["default"].unlinkSync(filePath);

                    cleanupCallback();
                    throw error;
                  }));

                case 21:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));

        return function (_x) {
          return _ref.apply(this, arguments);
        };
      }())["catch"](function (error) {
        if (error.response) {
          reject(new Error("Invalid status code for ".concat(encodedFileUrl, ": ").concat(error.response.status)));
        } else {
          reject(error);
        }
      });
    });
  });
  return {
    promise: promise,
    cancel: function cancel() {
      _cancel();
    }
  };
}